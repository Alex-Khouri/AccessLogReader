/*
*AUTHOR: Alexander Khouri
*/

import java.util.*;
import java.io.*;
import java.time.*;

public class AccessLogReader {
    // Used for array values in hashmaps
    final static int COUNT = 0;
    final static int DATA = 1;
    final static int LAST = 2;
    final static int SIZE = 0;
    final static int GAP = 0;
    final static int PROB = 1;
    final static int CDF = 2;

    // Reference data
    static String[] sortedWeekdays = new String[] {"MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"};
    static String[] sortedCodes = new String[] {"200", "302", "304", "4XX", "5XX"};
    static String[] sortedFileTypes = new String[] {"html", "images", "sound", "video", "formatted", "dynamic", "other"};
    static HashMap<String, Integer> monthMap = new HashMap<String, Integer>();
    static HashMap<String, HashSet<String>> extMap = new HashMap<String, HashSet<String>>();

    // Data generated by analysis
    static long localReqs = 0;
    static long remoteReqs = 0;
    static long totalReqs = 0;
    static long localData = 0;
    static long remoteData = 0;
    static long uniqueData = 0;
    static long totalData = 0;
    static long successReqs = 0;
    static long successData = 0;
    static long oneTimeFiles = 0;
    static long oneTimeData = 0;
    static long successFiles = 0;
    static long totalRepeats = 0;
    static long[][] hours = new long[][] {{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}}; // [x]=hour [x][0]=Count [x][1]=Total Data
    static long[][] months = new long[][] {{0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}, {0,0}}; // [x]=month [x][0]=Count [x][1]=Total Data
    static HashMap<String, long[]> weekdays = new HashMap<String, long[]>(); // [0]=Count [1]=Total Data
    static HashMap<String, long[]> dates = new HashMap<String, long[]>(); // [0]=Count [1]=Total Data
    static HashMap<String, long[]> codes = new HashMap<String, long[]>(); // [0]=Count [1]=Total Data
    static HashMap<String, long[]> files = new HashMap<String, long[]>(); // [0]=Count [1]=Total Data [2]= Last Accessed (epoch seconds)
    static HashMap<String, double[]> sizeCDF = new HashMap<String, double[]>(); // [0]=File Size [1]=Probability [2]=CDF
    static HashMap<Long, double[]> gapCDF = new HashMap<Long, double[]>(); // Key=Gap [0]=Count [1]=Probability [2]=CDF
    static HashMap<String, long[]> fileTypes = new HashMap<String, long[]>(); // [0]=Count [1]=Total Data

    public static void main(String[] args) {
        initStructs();
        readInput("UofS_access_log.txt");
        writeOutput("Access_Log_Main_Data.txt", "Access_Log_Size_CDF_Data.txt", "Access_Log_Period_Data.txt", "Access_Log_Gap_CDF_Data.txt");
    }

    private static void readInput(String readFile) {
        int lineNum = 1; // Used for debugging
        try { // Read input file
            BufferedReader reader = new BufferedReader(new FileReader(readFile));
            String line;
            while ((line = reader.readLine()) != null) {
                if (validLine(line)) {
                    String host = line.substring(0, line.indexOf(" "));

                    // Parse date and time
                    String dateTimeStr = line.substring(line.indexOf("[") + 1, line.indexOf("]"));
                    String date = dateTimeStr.split(":")[0];
                    int day = Integer.parseInt(date.split("/")[0]);
                    int month = monthMap.get(date.split("/")[1]);
                    int year = Integer.parseInt(date.split("/")[2]); 
                    int hour = Integer.parseInt(dateTimeStr.split(":")[1]);
                    int minute = Integer.parseInt(dateTimeStr.split(":")[2]);
                    int second = Integer.parseInt(dateTimeStr.split(":")[3].substring(0, 2));
                    LocalDateTime dateTime = LocalDateTime.of(year, month + 1, day, hour, minute, second);
                    String weekday = dateTime.getDayOfWeek().toString();
                    long epochSec = dateTime.toEpochSecond(ZoneOffset.UTC);

                    // Parse HTTP request
                    String request = line.substring(line.indexOf("\"") + 1, line.lastIndexOf("\""));
                    String file = request.split(" ")[1];
                    String fileType = "other"; // Default value
                    if (file.length() > 0) {
                        if (file.charAt(file.length() - 1) == '/' ||
                            file.charAt(file.length() - 1) == '.') {
                            fileType = "html";
                        } else if (file.contains("?")) {
                            fileType = "dynamic";
                        }
                        else if (file.contains(".")) {
                            String fileExt = file.substring(file.lastIndexOf(".") + 1);
                            for (String type : extMap.keySet()) {
                                if (extMap.get(type).contains(fileExt)) {
                                    fileType = type;
                                    break;
                                }
                            }
                        }
                    }
                    String code = line.substring(line.lastIndexOf("\"") + 2, line.lastIndexOf(" "));
                    if (code.charAt(0) == '4') code = "4XX"; // Handle 400 codes
                    else if (code.charAt(0) == '5') code = "5XX"; // Handle 500 codes
                    String dataStr = line.substring(line.lastIndexOf(" ") + 1);
                    long data = dataStr.equals("-") ? 0 : Long.parseLong(dataStr);

                    // Process data into structures
                    totalReqs += 1;
                    totalData += data;
                    if (dates.containsKey(date)) { // Date data
                        dates.get(date)[COUNT] += 1;
                        dates.get(date)[DATA] += data;
                    } else dates.put(date, new long[] {1, data}); // Default
                    if (codes.containsKey(code)) { // Code data
                        codes.get(code)[COUNT] += 1;
                        codes.get(code)[DATA] += data;
                    }
                    if (code.equals("200")) { // i.e. Successful requests only
                        successReqs += 1;
                        successData += data;
                        if (safeSubstring(host, 0, 7).equals("128.233") || host.contains("usask.ca")) {
                            localReqs += 1;
                            localData += data;
                        } else {
                            remoteReqs += 1;
                            remoteData += data;
                        }
                        hours[hour][COUNT] += 1;
                        hours[hour][DATA] += data;
                        weekdays.get(weekday)[COUNT] += 1;
                        weekdays.get(weekday)[DATA] += data;
                        months[month][COUNT] += 1;
                        months[month][DATA] += data;
                        if (files.containsKey(file)) { // File data
                            long gapTime = epochSec - files.get(file)[LAST];
                            if (gapTime > 0) { // Some request times are out of order
                                totalRepeats += 1;
                                if (gapCDF.containsKey(gapTime)) gapCDF.get(gapTime)[COUNT] += 1.0;
                                else gapCDF.put(gapTime, new double[] {1.0, 0.0, 0.0}); // Probability evaluated later
                            }
                            files.get(file)[COUNT] += 1;
                            files.get(file)[DATA] += data;
                            files.get(file)[LAST] = epochSec;
                        } else {
                            files.put(file, new long[] {1, data, epochSec}); // Default
                        }
                        if (!sizeCDF.containsKey(file)) sizeCDF.put(file, new double[] {data, 0.0, 0.0}); // Probability evaluated later
                        if (fileTypes.containsKey(fileType)) { // File type data
                            fileTypes.get(fileType)[COUNT] += 1;
                            fileTypes.get(fileType)[DATA] += data;
                        }
                    }
                }
                lineNum += 1; // Used for debugging
            }
            reader.close();
        } catch(Exception e) {
            System.out.printf("ERROR WHILE READING LINE #%d OF INPUT FILE:\n%s\n", lineNum, e);
            System.exit(1);
        }

        // Process data
        successFiles = files.size();
        for (String file : files.keySet()) { // Process file size probabilities
            sizeCDF.get(file)[PROB] = (double) files.get(file)[COUNT] / successReqs;
            uniqueData += (long) sizeCDF.get(file)[SIZE];
            if (files.get(file)[COUNT] == 1) {
                oneTimeFiles += 1;
                oneTimeData += sizeCDF.get(file)[SIZE];
            }
        }
        for (Long gap : gapCDF.keySet()) { // Process inter-reference probabilities
            gapCDF.get(gap)[PROB] = gapCDF.get(gap)[COUNT] / totalRepeats;
        }
    }

    private static void writeOutput(String mainData, String sizeData, String periodData, String gapData) {
        try { // Write main data to text file
            BufferedWriter writer = new BufferedWriter(new FileWriter(mainData));
            writer.write("Total Requests: " + totalReqs + "\n");
            writer.write("Average Daily Requests: " + (double) totalReqs / dates.size() + "\n");
            writer.write("Total Data Transferred (MB): " + (double) totalData / 1000000 + "\n");
            writer.write("Average Daily Data (MB): " + ((double) totalData / dates.size()) / 1000000 + "\n");
            writer.write("----------\n");
            for (String code : sortedCodes) {
                writer.write(String.format("Percentage of %s Response Codes: %f%%\n", code, (double) codes.get(code)[COUNT] / totalReqs * 100));
            }
            writer.write("Percentage of Unsuccessful Response Codes: " + (double) (codes.get("4XX")[COUNT] + codes.get("5XX")[COUNT]) / totalReqs * 100 + "%\n");
            writer.write("----------\n");
            writer.write("Percentage of Requests Made By Local Clients: " + (double) localReqs / successReqs * 100 + "%\n");
            writer.write("Percentage of Requests Made By Remote Clients: " + (double) remoteReqs / successReqs * 100 + "%\n");
            writer.write("Percentage of Data Transferred By Local Clients (B): " + (double) localData / successData * 100 + "%\n");
            writer.write("Percentage of Data Transferred By Remote Clients (B): " + (double) remoteData / successData * 100 + "%\n");
            writer.write("----------\n~~~\n");
            for (String type : sortedFileTypes) {
                writer.write(String.format("Percentage of Requests for %s Files: %f%%\n", type, (double) fileTypes.get(type)[COUNT] / successReqs * 100));
                writer.write(String.format("Percentage of Data Transferred for %s Files: %f%%\n", type, (double) fileTypes.get(type)[DATA] / successData * 100));
                writer.write(String.format("Average Data Transferred for %s Files (B): %f\n~~~\n", type, fileTypes.get(type)[COUNT] == 0 ? 0 : (double) fileTypes.get(type)[DATA] / fileTypes.get(type)[COUNT])); // Safety check for zero division
            }
            writer.write("----------\n");
            writer.write("Percentage of Objects Accessed Once: " + ((double) oneTimeFiles / successFiles * 100) + "%\n");
            writer.write("Percentage of Data Accessed Once (B): " + ((double) oneTimeData / uniqueData * 100) + "%\n");
            writer.close();
        } catch (Exception e) {
            System.out.println("ERROR WHILE WRITING OUTPUT FILE:\n" + e);
            System.exit(1);
        }

        try { // Write size CDF data to text file
            BufferedWriter writer = new BufferedWriter(new FileWriter(sizeData));
            String[] sortedFiles = sizeCDF.keySet().toArray(new String[sizeCDF.size()]); // Sorted by size
            Arrays.sort(sortedFiles, new Comparator<String>() {
                public int compare(String str1, String str2) {
                    if (sizeCDF.get(str1)[SIZE] < sizeCDF.get(str2)[SIZE]) return -1;
                    else if (sizeCDF.get(str1)[SIZE] > sizeCDF.get(str2)[SIZE]) return 1;
                    else return 0;
                }
            });
            double cdf = 0.0;
            for (String file : sortedFiles) {
                cdf += sizeCDF.get(file)[PROB];
                sizeCDF.get(file)[CDF] = cdf;
            }
            writer.write("Cumulative Distribution Function (CDF) of File Sizes:\n");
            for (String file : sortedFiles) {
                String size = (long) sizeCDF.get(file)[SIZE] + "";
                String padding = "";
                for (int i = size.length(); i < 15; i++) {padding += " ";}
                writer.write(size + padding + "\t" + sizeCDF.get(file)[CDF] + "\n");
            }
            writer.close();
        } catch (Exception e) {
            System.out.println("ERROR WHILE WRITING OUTPUT FILE:\n" + e);
            System.exit(1);
        }

        try { // Write period data to text file
            BufferedWriter writer = new BufferedWriter(new FileWriter(periodData));
            writer.write("Percentage of Requests Per Hour of the Day:\n");
            for (int hour = 0; hour < hours.length; hour++) {
                writer.write(hour + "\t" + ((double) hours[hour][COUNT] / successReqs * 100) + "%\n");
            }

            writer.write("\nPercentage of Requests Per Day of the Week:\n");
            for (String weekday : sortedWeekdays) {
                String padding = "";
                for (int i = weekday.length(); i < 8; i++) {padding += " ";}
                writer.write(weekday + padding + "\t" + ((double) weekdays.get(weekday)[COUNT] / successReqs * 100) + "%\n");
            }

            writer.write("\nPercentage of Requests Per Month of the Year:\n");
            for (int month = 0; month < months.length; month++) {
                for (String monthName : monthMap.keySet()) {
                    if (monthMap.get(monthName) == month) {
                        writer.write(monthName + "\t" + ((double) months[month][COUNT] / successReqs * 100) + "%\n");
                        break;
                    }
                }
                
            }
            writer.close();
        } catch (Exception e) {
            System.out.println("ERROR WHILE WRITING OUTPUT FILE:\n" + e);
            System.exit(1);
        }

        try { // Write gap CDF data to text file
            BufferedWriter writer = new BufferedWriter(new FileWriter(gapData));
            Long[] sortedGaps = gapCDF.keySet().toArray(new Long[gapCDF.size()]); // Sorted by size
            Arrays.sort(sortedGaps);
            double cdf = 0.0;
            for (Long gap : sortedGaps) {
                cdf += gapCDF.get(gap)[PROB];
                gapCDF.get(gap)[CDF] = cdf;
            }
            writer.write("Cumulative Distribution Function (CDF) of Inter-Reference Times:\n");
            for (Long gap : sortedGaps) {
                String gapStr = gap + "";
                String padding = "";
                for (int i = gapStr.length(); i < 15; i++) {padding += " ";}
                writer.write(gapStr + padding + "\t" + gapCDF.get(gap)[CDF] + "\n");
            }
            writer.close();
        } catch (Exception e) {
            System.out.println("ERROR WHILE WRITING OUTPUT FILE:\n" + e);
            System.exit(1);
        }
    }

    private static void initStructs() {
        monthMap.put("Jan", 0);
        monthMap.put("Feb", 1);
        monthMap.put("Mar", 2);
        monthMap.put("Apr", 3);
        monthMap.put("May", 4);
        monthMap.put("Jun", 5);
        monthMap.put("Jul", 6);
        monthMap.put("Aug", 7);
        monthMap.put("Sep", 8);
        monthMap.put("Oct", 9);
        monthMap.put("Nov", 10);
        monthMap.put("Dec", 11);
        extMap.put("html", new HashSet(Arrays.asList("html", "htm", "shtml", "map")));
        extMap.put("images", new HashSet(Arrays.asList("gif", "jpeg", "jpg", "xbm", "bmp", "rgb", "xpm")));
        extMap.put("sound", new HashSet(Arrays.asList("au", "snd", "wav", "mid", "midi", "lha", "aif", "aiff")));
        extMap.put("video", new HashSet(Arrays.asList("mov", "movie", "avi", "qt", "mpeg", "mpg")));
        extMap.put("formatted", new HashSet(Arrays.asList("ps", "eps", "doc", "dvi", "txt")));
        extMap.put("dynamic", new HashSet(Arrays.asList("cgi", "pl", "cgi-bin")));
        weekdays.put("MONDAY", new long[]{0,0});
        weekdays.put("TUESDAY", new long[]{0,0});
        weekdays.put("WEDNESDAY", new long[]{0,0});
        weekdays.put("THURSDAY", new long[]{0,0});
        weekdays.put("FRIDAY", new long[]{0,0});
        weekdays.put("SATURDAY", new long[]{0,0});
        weekdays.put("SUNDAY", new long[]{0,0});
        codes.put("200", new long[]{0,0});
        codes.put("302", new long[]{0,0});
        codes.put("304", new long[]{0,0});
        codes.put("4XX", new long[]{0,0});
        codes.put("5XX", new long[]{0,0});
        fileTypes.put("html", new long[]{0,0});
        fileTypes.put("images", new long[]{0,0});
        fileTypes.put("sound", new long[]{0,0});
        fileTypes.put("video", new long[]{0,0});
        fileTypes.put("formatted", new long[]{0,0});
        fileTypes.put("dynamic", new long[]{0,0});
        fileTypes.put("other", new long[]{0,0});
    }

    private static boolean validLine(String line) {
        String request = line.substring(line.indexOf("\"") + 1, line.lastIndexOf("\""));
        String dateTimeStr = line.substring(line.indexOf("[") + 1, line.lastIndexOf("]"));
        return line.length() > 40 && line.contains(":") && line.contains("/") && line.contains("\"") && !dateTimeStr.contains("[") && !dateTimeStr.contains("]") && request.contains(" ");
    }
    private static String safeSubstring(String text, int start, int stop) {
        if (stop > text.length() || start > stop) {
            if (start >= text.length() || start > stop) return text;
            else return text.substring(start);
        }
        else return text.substring(start, stop);
    }
}